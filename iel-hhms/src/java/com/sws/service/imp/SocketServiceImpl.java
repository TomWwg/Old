package com.sws.service.imp;import java.io.DataInputStream;import java.io.DataOutputStream;import java.io.IOException;import java.net.Socket;import java.util.ArrayList;import java.util.Date;import java.util.HashMap;import java.util.List;import java.util.Map;import java.util.concurrent.BlockingQueue;import java.util.concurrent.LinkedBlockingQueue;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.beans.factory.annotation.Autowired;import com.sws.common.entity.SendData;import com.sws.common.until.ByteUtil;import com.sws.common.until.DateUtils;import com.sws.model.ParameterInfo;import com.sws.service.ParameterInfoService;import com.sws.service.SocketService;public class SocketServiceImpl implements SocketService {	private static Logger log = LoggerFactory.getLogger(SocketServiceImpl.class);	@Autowired	private ParameterInfoService parameterInfoService;	private int cmdSeq = 0x8000;	private static Map<Integer, byte[]> recMap = new HashMap<Integer, byte[]>();// 结束后返回的字节 <命令包序号,返回字节>//	private Map<Integer, SendData> sendMap = new HashMap<Integer, SendData>();// <命令包序号,命令发送数据结构体>	private static BlockingQueue<SendData> sendQueue = new LinkedBlockingQueue<SendData>();	private class socketThread extends Thread {		String serverIp="127.0.0.1";		Integer serverPort=8067;		public Socket socket = null;		public socketThread() {			try {				ParameterInfo ipInfo = parameterInfoService.findByTypeAndKey(2, "ip");				ParameterInfo portInfo = parameterInfoService.findByTypeAndKey(2, "port");				if (socket != null) {					return;				}				if(ipInfo!=null&&ipInfo.getValue()!=null){					serverIp = ipInfo.getValue();				}				if(portInfo!=null&&portInfo.getValue()!=null){					serverPort = Integer.valueOf(portInfo.getValue());				}				socket = new Socket(serverIp, serverPort);  	 			} catch (IOException e) {				return;			}			setDaemon(true);			start();		}   //建立socket通讯 		public void run() {			byte[] recBuf;			DataInputStream recStream = null;			DataOutputStream sendStream = null;			try {				recStream = new DataInputStream(socket.getInputStream());//接收数据流(收件箱)				sendStream = new DataOutputStream(socket.getOutputStream());//发送数据流(发件箱)			} catch (IOException e1) {				// TODO Auto-generated catch block				e1.printStackTrace();			} 			while(true){				try {					SendData cmdBuf = sendQueue.take();					log.info("cmdBuf cmd 0x:"+Integer.toHexString(cmdBuf.getSeq()));					log.info("recMap size:"+String.valueOf(recMap.size()));					sendStream.write(cmdBuf.getData());					sendStream.flush();					//socket.shutdownOutput();//关闭输出流					recBuf = new byte[13];					recStream.read(recBuf);					//解析recBuf，清除相应的数据列					if(recBuf.length==13){//返回的08报文，目前两种执行成功或者失败：00或者其他						Integer seq = ByteUtil.byteToInt(recBuf, 2, 2);						recMap.put(seq, recBuf);					}				} catch (InterruptedException e) {					// TODO Auto-generated catch block					e.printStackTrace();				} catch (IOException e) {					// TODO Auto-generated catch block					e.printStackTrace();				}finally {					if(recStream != null) {    					try {    						recStream.close();    					} catch (IOException e1) {    						e1.printStackTrace();    					}    				}					if(sendStream != null) {    					try {    						sendStream.close();    					} catch (IOException e1) {    						e1.printStackTrace();    					}    				}					if(socket != null) {						try {							socket.close();						} catch (IOException e1) {							e1.printStackTrace();						}							}					//	recMap.clear();					log.error("socket close!");				}			}			/*while (!sendMap.isEmpty()&&sendMap.size()>0) {				try {					Thread.sleep(50);					SendData sendData = sendMap.get(0);					sendStream.write(sendData.getData());					sendStream.flush();					sendMap.remove(0);  //发送后删除					recBuf = new byte[13];					recStream.read(recBuf);					//解析recBuf，清除相应的数据列					if(recBuf.length==13){//返回的08报文，目前两种执行成功或者失败：00或者其他						Integer seq = ByteUtil.byteToInt(recBuf, 2, 2);						recMap.put(seq, recBuf);					}				} catch (InterruptedException e) {					// TODO Auto-generated catch block					e.printStackTrace();				} catch (IOException e) {					// TODO Auto-generated catch block					e.printStackTrace();				}							}*/		}			}	protected byte[] intToByte2(int i) {		byte[] result = new byte[2];		result[0] = (byte) (i & 0xFF);		result[1] = (byte) ((i >> 8) & 0xFF);		return result;	}	// 命令序号，用于上位和前置机通信唯一标识	private Integer getCmdSeq() {		if (cmdSeq == 0xFFFF) {			cmdSeq = 0x8000;		} else {			cmdSeq++;		}		return cmdSeq;	}		/*private static Runnable queueTask() {        return new Runnable() {            public void run() {// 处理队列数据				String serverIp = "127.0.0.1";				Integer serverPort = 8067;				Socket socket = null;				DataInputStream recStream = null;				DataOutputStream sendStream = null;				byte[] recBuf;				try {					ParameterInfoService parameterInfoService = ServiceLocator.findService("parameterInfoService");					ParameterInfo ipInfo = parameterInfoService.findByTypeAndKey(2, "ip");					ParameterInfo portInfo = parameterInfoService.findByTypeAndKey(2, "port");					if(ipInfo!=null&&ipInfo.getValue()!=null){						serverIp = ipInfo.getValue();					}					if(portInfo!=null&&portInfo.getValue()!=null){						serverPort = Integer.valueOf(portInfo.getValue());					}					socket = new Socket(serverIp, serverPort);  					recStream = new DataInputStream(socket.getInputStream()); //接收数据流(收件箱)					sendStream = new DataOutputStream(socket.getOutputStream()); //发送数据流(发件箱)					while (true) {						try {							SendData cmdBuf = sendQueue.take();							log.info("cmdBuf cmd 0x:"+Integer.toHexString(cmdBuf.getSeq()));							log.info("recMap size:"+String.valueOf(recMap.size()));							sendStream.write(cmdBuf.getData());							sendStream.flush();//发送 							//关闭输出流				            socket.shutdownOutput();							recBuf = new byte[13];							recStream.read(recBuf); //接收 							//解析recBuf，清除相应的数据列							if(recBuf.length==13){//返回的08报文，目前两种执行成功或者失败：00或者其他								Integer seq = ByteUtil.byteToInt(recBuf, 2, 2);								recMap.put(seq, recBuf);							}						} catch (Throwable e) {							log.error("get data from Queue has Exception:{}", e);							if(recStream != null) {		    					try {		    						recStream.close();		    					} catch (IOException e1) {		    						e1.printStackTrace();		    					}		    				}							if(sendStream != null) {		    					try {		    						sendStream.close();		    					} catch (IOException e1) {		    						e1.printStackTrace();		    					}		    				}							if(socket != null) {								try {									socket.close();								} catch (IOException e1) {									e1.printStackTrace();								}									}								recMap.clear();							log.error("socket close!");						}					}				} catch (UnknownHostException e1) {					// TODO Auto-generated catch block					e1.printStackTrace();				} catch (IOException e1) {					// TODO Auto-generated catch block					e1.printStackTrace();				}finally {									}				            }        };    }*/		@Override	public List<Integer> send(List<byte[]> list,byte funCode,byte[] apNo) {  		byte[] dataSum = new byte[37];		List<Integer> seqs = new ArrayList<Integer>();		for(byte[] data:list){			Integer seq = getCmdSeq();			System.arraycopy(ByteUtil.intToByte2(37),0, dataSum,0,2);			System.arraycopy(ByteUtil.intToByte2(seq),0, dataSum,2,2);			dataSum[4] = funCode;			System.arraycopy(apNo,0, dataSum,5,4);			System.arraycopy(data,0, dataSum,9,28);//数据从新封装			SendData sendData = new SendData();			sendData.setData(dataSum);			sendData.setSendDate(new Date());			sendData.setSeq(seq);			sendQueue.add(sendData);		//	sendMap.put(seq, sendData);			seqs.add(seq);		}//发送Map 	    new socketThread();		// ThreadExecutorService.execute(queueTask());		return seqs;	}	@Override	public byte[] time6Byte() {		Date date = new Date();		byte[] time = new byte[6];		time[0]=Int2BCD(DateUtils.getYear(date)-2000);		time[1]=Int2BCD(DateUtils.getMonth(date)+1);		time[2]=Int2BCD(DateUtils.getDay(date));		time[3]=Int2BCD(DateUtils.getHour(date));		time[4]=Int2BCD(DateUtils.getMin(date));		time[5]=Int2BCD(DateUtils.getSecond(date));		return time;	}	private byte Int2BCD(int i) {		byte b = 0;		int move = 0;		while (i > 0) {			b = (byte) (b | (i % 10) << move);			i /= 10;			move += 4;		}		return b;	}		@Override	public byte[] getResultBySeq(Integer seq) {// 根据命令包序号		Long start = System.currentTimeMillis();		byte[] result = null;		while (true) {			try {				Thread.sleep(500);// 0.5秒间隔运行				Long end = System.currentTimeMillis();				if (end - start > 25000) {// 60秒超时时间					result=backError(seq);//通讯失败					break;				}				result = recMap.get(seq);				if (result != null) {					recMap.remove(seq);//返回值取出后，从返回队列清除					break;				}			} catch (InterruptedException e) {				// TODO Auto-generated catch block				e.printStackTrace();			}		}		return result;	}	private byte[] backError(Integer seq) {		byte[] back = new byte[13];		for(byte i=0;i<13;i++){			back[i]=0x0;		}		System.arraycopy(ByteUtil.intToByte2(13),0, back,0,2);		System.arraycopy(ByteUtil.intToByte2(seq),0, back,2,2);		System.arraycopy(ByteUtil.intToByte2(1),0, back,4,2);		back[6]=0x08;		back[11]=0x03;		return back;	}}